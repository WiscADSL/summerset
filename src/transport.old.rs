//! Server internal RPC transport module implementation.

use std::collections::HashMap;

use crate::utils::{SummersetError, InitError};

use tonic::{Request, Response, Status};
use tonic::transport;

/// Helper macro for wrapping a `BoxFuture`-flavor closure over a tonic
/// client async connection method.
/// Usage example: `connect_fn!(SimplePushClient, connect)`.
///
/// The `async move` sub-closure is needed to enforce the returned future to
/// directly move the `Arc<_>` argument instead of capturing a reference to it.
#[macro_export]
macro_rules! connect_fn {
    ($cli:ident, $fn:ident) => {
        |addr| Box::pin(async move { $cli::$fn(addr).await })
    };
}

/// Helper macro for wrapping a `BoxFuture`-flavor closure over a tonic
/// client RPC async issuer method.
/// Usage example: `rpc_fn!(SimplePushClient, push_record)`.
///
/// The `async move` sub-closure is needed to enforce the returned future to
/// directly move the `Arc<_>` argument instead of capturing a reference to it.
#[macro_export]
macro_rules! rpc_fn {
    ($cli:ident, $fn:ident) => {
        |conn, req| {
            Box::pin(
                async move { $cli::$fn(&mut *conn.borrow_mut(), req).await },
            )
        }
    };
}

/// Server internal RPC transport module.
#[derive(Debug)]
pub struct TransportHub<Conn> {
    /// Map from peer ID -> RPC client connection.
    peers: HashMap<u8, Conn>,
}

impl<Conn> TransportHub<Conn> {
    /// Create a new server internal RPC sender struct.
    pub fn new() -> Self {
        TransportHub {
            peers: HashMap::new(),
        }
    }

    /// Connect to one address and block until acknowledgement.
    /// This function is provided as a generic function due to the fact that
    /// each tonic protobuf client is a different type generated by prost.
    /// Returns `Ok(C)` containing the protobuf RPC client on success.
    ///
    /// Uses `BoxFuture` as a level of indirection to allow passing in
    /// different tonic client connect async functions.
    #[allow(clippy::type_complexity)]
    pub async fn connect<Conn>(
        &self,
        connect_fn: fn(
            String,
        )
            -> BoxFuture<'static, Result<Conn, transport::Error>>,
        peer_addr: String,
    ) -> Result<Conn, SummersetError> {
        let addr_str = format!("http://{}", &peer_addr);
        async move { connect_fn(addr_str).await }
            .await
            .map_err(|e| {
                SummersetError::TonicConnError(format!(
                    "failed to connect to address {}: {}",
                    peer_addr, e
                ))
            })
    }

    /// Send RPC request to one connection and block until acknowledgement.
    /// This function is provided as a generic function due to the fact that
    /// each tonic protobuf client and request/reply is a different type
    /// generated by prost. Returns `Ok(Reply)` containing the RPC reply on
    /// success.
    ///
    /// Uses `BoxFuture` as a level of indirection to allow passing in
    /// different tonic client RPC async issuer functions.
    #[allow(clippy::type_complexity)]
    pub async fn send_rpc<Conn, Req, Resp>(
        &self,
        rpc_fn: fn(
            Arc<AtomicRefCell<Conn>>,
            Request<Req>,
        )
            -> BoxFuture<'static, Result<Response<Resp>, Status>>,
        request: Req,
        peer_conn: Arc<AtomicRefCell<Conn>>,
    ) -> Result<Resp, SummersetError> {
        rpc_fn(peer_conn, Request::new(request))
            .await
            .map(|r| r.into_inner())
            .map_err(|e| {
                SummersetError::TonicConnError(format!(
                    "failed to send RPC to connection: {}",
                    e
                ))
            })
    }
}
