//! Tonic RPC async sender helper struct and methods.
//!
//! TODO: build a generic transport layer and support transports other than
//! RPCs, e.g., thread channels and IPC sockets.

use std::collections::HashMap;
use std::sync::Arc;

use crate::utils::{SummersetError, InitError};

use tonic::{Request, Response, Status};
use tonic::transport;

use tokio::task::JoinSet;

use futures::future::BoxFuture;

use atomic_refcell::AtomicRefCell;

/// Helper macro for wrapping a `BoxFuture`-flavor closure over a tonic
/// client async connection method.
/// Usage example: `connect_fn!(SimplePushClient, connect)`.
///
/// The `async move` sub-closure is needed to enforce the returned future to
/// directly move the `Arc<_>` argument instead of capturing a reference to it.
#[macro_export]
macro_rules! connect_fn {
    ($cli:ident, $fn:ident) => {
        |addr| Box::pin(async move { $cli::$fn(addr).await })
    };
}

/// Helper macro for wrapping a `BoxFuture`-flavor closure over a tonic
/// client RPC async issuer method.
/// Usage example: `rpc_fn!(SimplePushClient, push_record)`.
///
/// The `async move` sub-closure is needed to enforce the returned future to
/// directly move the `Arc<_>` argument instead of capturing a reference to it.
#[macro_export]
macro_rules! rpc_fn {
    ($cli:ident, $fn:ident) => {
        |conn, req| {
            Box::pin(
                async move { $cli::$fn(&mut *conn.borrow_mut(), req).await },
            )
        }
    };
}

/// Tonic RPC sender state struct and helper functions.
#[derive(Debug)]
pub struct TonicRPCSender {}

impl TonicRPCSender {
    /// Create a new server internal RPC sender struct.
    pub fn new() -> Result<Self, InitError> {
        Ok(TonicRPCSender {})
    }

    /// Connect to one address and block until acknowledgement.
    /// This function is provided as a generic function due to the fact that
    /// each tonic protobuf client is a different type generated by prost.
    /// Returns `Ok(C)` containing the protobuf RPC client on success.
    ///
    /// Uses `BoxFuture` as a level of indirection to allow passing in
    /// different tonic client connect async functions.
    #[allow(clippy::type_complexity)]
    pub async fn connect<Conn>(
        &self,
        connect_fn: fn(
            String,
        )
            -> BoxFuture<'static, Result<Conn, transport::Error>>,
        peer_addr: String,
    ) -> Result<Conn, SummersetError> {
        let addr_str = format!("http://{}", &peer_addr);
        async move { connect_fn(addr_str).await }
            .await
            .map_err(|e| {
                SummersetError::TonicConnError(format!(
                    "failed to connect to address {}: {}",
                    peer_addr, e
                ))
            })
    }

    /// Connect to multiple addresses and block until all of the connections
    /// have been established. On success, returns `Ok(HashMap<u64, Conn>)`
    /// containing a map from peer ID to protobuf RPC client structs. Returns
    /// error immediately if any of them fails.
    ///
    /// Uses `BoxFuture` as a level of indirection to allow passing in
    /// different tonic client connect async functions.
    #[allow(clippy::type_complexity)]
    pub async fn connect_multi<Conn>(
        &self,
        connect_fn: fn(
            String,
        )
            -> BoxFuture<'static, Result<Conn, transport::Error>>,
        peer_addrs: HashMap<u64, String>,
    ) -> Result<HashMap<u64, Conn>, SummersetError>
    where
        Conn: Send + 'static,
    {
        let num_addrs = peer_addrs.len();
        if num_addrs == 0 {
            return Ok(HashMap::new());
        }

        // spawn all futures concurrently, prefixing the results with ID
        let mut jset = JoinSet::new();
        for (&id, addr) in peer_addrs.iter() {
            let addr_str = format!("http://{}", &addr);
            jset.spawn(async move { (id, connect_fn(addr_str).await) });
        }

        // join them in order of completion
        let mut conns = HashMap::with_capacity(num_addrs);
        while let Some(jres) = jset.join_next().await {
            if let Err(je) = jres {
                jset.abort_all();
                return Err(SummersetError::TonicConnError(format!(
                    "join error in connect_multi: {}",
                    je
                )));
            }

            // `tres` is a `Result<Conn, tonic::transport::Error>`
            let (id, tres) = jres.unwrap();
            if let Err(te) = tres {
                jset.abort_all();
                return Err(SummersetError::TonicConnError(format!(
                    "failed to connect to address {}: {}",
                    &peer_addrs.get(&id).unwrap(),
                    te
                )));
            }
            conns.insert(id, tres.unwrap());
        }

        assert!(conns.len() == num_addrs);
        Ok(conns)
    }

    /// Send RPC request to one connection and block until acknowledgement.
    /// This function is provided as a generic function due to the fact that
    /// each tonic protobuf client and request/reply is a different type
    /// generated by prost. Returns `Ok(Reply)` containing the RPC reply on
    /// success.
    ///
    /// Uses `BoxFuture` as a level of indirection to allow passing in
    /// different tonic client RPC async issuer functions.
    #[allow(clippy::type_complexity)]
    pub async fn send_rpc<Conn, Req, Resp>(
        &self,
        rpc_fn: fn(
            Arc<AtomicRefCell<Conn>>,
            Request<Req>,
        )
            -> BoxFuture<'static, Result<Response<Resp>, Status>>,
        request: Req,
        peer_conn: Arc<AtomicRefCell<Conn>>,
    ) -> Result<Resp, SummersetError> {
        rpc_fn(peer_conn, Request::new(request))
            .await
            .map(|r| r.into_inner())
            .map_err(|e| {
                SummersetError::TonicConnError(format!(
                    "failed to send RPC to connection: {}",
                    e
                ))
            })
    }

    /// Send RPCs to multiple peer connections and block until all have been
    /// replied. On success, returns `Ok(HashMap<u64, Reply>)` containing a
    /// map from peer ID to desired reply structs. Returns error immediately
    /// if any of them fails.
    ///
    /// Uses `BoxFuture` as a level of indirection to allow passing in
    /// different tonic client RPC async issuer functions.
    #[allow(clippy::type_complexity)]
    pub async fn send_rpc_multi<Conn, Req, Resp>(
        &self,
        rpc_fn: fn(
            Arc<AtomicRefCell<Conn>>,
            Request<Req>,
        )
            -> BoxFuture<'static, Result<Response<Resp>, Status>>,
        request: Req,
        peer_conns: HashMap<u64, Arc<AtomicRefCell<Conn>>>,
    ) -> Result<HashMap<u64, Resp>, SummersetError>
    where
        Conn: Send + Sync + 'static,
        Req: Send + Clone + 'static,
        Resp: Send + 'static,
    {
        let num_conns = peer_conns.len();
        if num_conns == 0 {
            return Ok(HashMap::new());
        }

        // spawn all futures concurrently, prefixing the results with ID
        let mut jset = JoinSet::new();
        for (id, conn) in peer_conns.into_iter() {
            let req_copy = request.clone();
            jset.spawn(async move {
                (id, rpc_fn(conn, Request::new(req_copy)).await)
            });
        }

        // join them in order of completion
        let mut replies = HashMap::with_capacity(num_conns);
        while let Some(jres) = jset.join_next().await {
            if let Err(je) = jres {
                jset.abort_all();
                return Err(SummersetError::TonicConnError(format!(
                    "join error in send_rpc_multi: {}",
                    je
                )));
            }

            // `tres` is a `Result<Conn, tonic::Status>`
            let (id, tres) = jres.unwrap();
            if let Err(te) = tres {
                jset.abort_all();
                return Err(SummersetError::TonicConnError(format!(
                    "failed to send RPC to connection: {}",
                    te
                )));
            }
            replies.insert(id, tres.unwrap().into_inner());
        }

        assert!(replies.len() == num_conns);
        Ok(replies)
    }
}
